{{#partial "body"}}
<div class="drawer drawer-mobile">
    <ul id="contextMenu" class="menu bg-base-100 w-56 hidden absolute z-10">
        <li id="replyButton"><a href="#">Reply</a></li>
    </ul>
    <input id="my-drawer-2" type="checkbox" class="drawer-toggle"/>

    <div class="drawer-content flex flex-col p-2">

        <div class="messages-container-wrapper flex-1 min-h-0 overflow-auto py-2">

            <div class="messages-container flex flex-col justify-end min-h-full">
            </div>
        </div>
        <div id="repliedMessageContainer" class="alert shadow-lg hidden">
            <div id="repliedMessageSection">
                <svg class="h-5 w-5 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                          d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6"/>
                </svg>
                <span></span>
            </div>
        </div>
        <form>
            <input class="input input-bordered input-primary w-full" id="message-input" type="text"
                   placeholder="type something..." autocomplete="off">
        </form>
    </div>
    <div class="drawer-side">
        <label for="my-drawer-2" class="drawer-overlay"></label>
        <div class="bg-base-200">
            <h2 class="text-2xl max-h-8 text-center pt-2">Users</h2>
            <ul id="user-list" class="menu p-4 w-80  text-base-content">
            </ul>
        </div>
    </div>
</div>


<script>
    const repliedMessageContainer = document.querySelector("#repliedMessageContainer");
    const contextMenu = document.querySelector("#contextMenu");
    const drawer = document.querySelector(".drawer");
    const userList = document.querySelector("#user-list");
    const messagesContainer = document.querySelector(".messages-container");
    const messageInput = document.querySelector("#message-input");
    const messagesContainerWrapper = document.querySelector(".messages-container-wrapper");
    const MESSAGES_COLORS = [
        'bg-primary',
        'bg-primary-focus',
        'bg-secondary',
        'bg-secondary-focus',
    ];
    let users = [];
    const messages = {};
    let repliedMessage;
    let bottom = true;


    document.addEventListener('click', (e) => {
        contextMenu.classList.add("hidden");
    })

    function showCustomContextMenu(id, event) {
        contextMenu.classList.remove("hidden");
        repliedMessage = messages[id];
        contextMenu.style.left = event.pageX + "px";
        contextMenu.style.top = event.pageY + "px";
        event.preventDefault();
    }

    function hideCustomContextMenu() {
        contextMenu.classList.add("hidden");
    }

    drawer.addEventListener('contextmenu', (e) => {
        if (e.target.classList.contains('.chat-bubble') ||
            // ??
            e.target.closest('.chat-bubble') !== null) {
            contextMenu.classList.remove("hidden");
        } else {
            contextMenu.classList.add("hidden");
        }
    });

    function addRepliedMessageSection() {
        document.querySelector("#replyButton").addEventListener('click', () => {
            repliedMessageContainer.classList.remove("hidden");
            document.querySelector("#repliedMessageSection span").innerHTML = repliedMessage.message;

        });
    }


    function displayUsers() {
        let userListHtml = "";
        for (const user of users) {
            const online = Date.now() - user.lastActivityAt < 30000;
            userListHtml += `
                 <li class="border rounded-xl mb-2 ${online ? 'border-primary' : 'border-gray-400'}">
                    <a class="flex justify-between">
                       <strong>${user.username}</strong>
                       <i class="w-3 h-3 rounded-full ${online ? 'bg-primary' : 'bg-gray-400'}"></i>
                    </a>
                 </li>
                `;
        }
        userList.innerHTML = userListHtml;
    }

    setInterval(displayUsers, 1000);

    function randomMessageColor() {
        return MESSAGES_COLORS[Math.floor(Math.random() * MESSAGES_COLORS.length)]
    }

    fetch("/api/users")
        .then(r => r.json())
        .then(r => {
            users = r.users;
            displayUsers();
        });

    document.querySelector('form').addEventListener("submit", function (event) {
        event.preventDefault();
        const message = messageInput.value;
        if (!message) {
            return;
        }
        // TODO Избавиться от копипаста
        const body = {message};
        if (!repliedMessageContainer.classList.contains("hidden")) {
            body.repliedMessageId = repliedMessage.id;
            repliedMessageContainer.classList.add("hidden");
        }
        fetch("/api/messages", {
            method: "POST",
            body: JSON.stringify(body)
        });
        messageInput.value = "";
    });

    function addMessage(message) {
        const repliedMessage = message.repliedMessage;
        let repliedMessageHTML = "";

        if (message.repliedMessage) {
            repliedMessageHTML = `
               <div class="flex gap-2 w-auto bg-black bg-opacity-25 rounded-lg p-4 text-sm text-gray-300 mb-1">
                  <i class="block h-100 bg-white bg-opacity-20 rounded-md w-1 mt-1" style="min-width: 4px;"></i>
                     <div>
                       <div class="font-semibold mb-1">${repliedMessage.username}</div>
                       <div class="">${repliedMessage.message}</div>
                     </div>
               </div>
        `
        }
        let messageHTML = `
               <div class="chat chat-start">
                 <div class="chat-header font-bold mb-1">${message.username}</div>
                   <div oncontextmenu="showCustomContextMenu('${message.id}', event)"
                        onclick="hideCustomContextMenu()"
                        class="chat-bubble w-auto max-w-4xl text-gray-200 ${randomMessageColor()}">
                               ${repliedMessageHTML}
                               ${message.message}
                 </div>
               </div>
        `;
        addRepliedMessageSection();
        if (bottom === false) {
            messagesContainer.innerHTML = messageHTML + messagesContainer.innerHTML;
        } else {
            messagesContainer.innerHTML += messageHTML;
        }
    }

    messagesContainerWrapper.addEventListener('scroll', function () {
        console.log(messagesContainerWrapper.scrollTop)
        if (messagesContainerWrapper.scrollTop === 0) {
            // вернет массив сообщений
           const from = Object.values(messages).reduce(function (acc, curr) {
                return !acc || acc > curr.sendDate ? curr.sendDate : acc;
            }, null)
            displayMessages(from);
        }
    })

    function displayMessages(from) {
        const params = {count:20}
        if(from){
            params.from = from;
        }
       return fetch(`/api/messages?${new URLSearchParams(params).toString()}`)
            .then(r => r.json())
            .then(r => {
                for (const message of r.messages) {
                    bottom = false;
                    messages[message.id] = message;
                    addMessage(message);
                }
            })

    }

    displayMessages().then(()=> {
        const ts = Object.values(messages).reduce(function (acc, curr) {
            return !acc || acc < curr.sendDate ? curr.sendDate : acc;
        }, 0)
        poll(ts);
    });

    function poll(ts) {
        fetch(`/api/events?ts=${ts}`)
            .then(r => r.json())
            .then(r => {
                for (const event of r.events) {
                    if (ts < event.date) {
                        ts = event.date;
                    }
                    switch (event.type) {
                        case "NEW_MESSAGE":
                            const message = event.message;
                            bottom = true;
                            messages[message.id] = message;
                            addMessage(message);
                            break;
                        case "USER_ACTIVITY":
                            const user = users.find(u => u.username === event.username);
                            if (user) {
                                user.lastActivityAt = event.date;
                            } else {
                                users = [{
                                    username: event.username,
                                    lastActivityAt: event.date
                                }, ...users];
                            }
                            break;
                    }
                }
                requestAnimationFrame(() => messagesContainerWrapper.scrollTo({
                    top: messagesContainerWrapper.scrollHeight,
                    behavior: 'smooth'
                }))
                poll(ts);
            })
    }
</script>
{{/partial}}
{{> base}}